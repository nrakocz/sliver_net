
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/databunch.ipynb


def fullDisplay(df,max_rows=None,max_col=None,width=None):
    df_cp = df.style.set_properties( **{'width': f'{width}px'}) if width is not None else df.copy()
    with pd.option_context('display.max_rows', max_rows, 'display.max_columns', max_col,):
        display(df_cp)

from pathlib import Path
Path.ls = lambda x: list(x.iterdir())
Path.l  = lambda x: [i.absolute() for i in x.iterdir()]


import pandas as pd
from matplotlib import pyplot as plt
import  torch
from skimage import io, transform, exposure
from torchvision import transforms, utils
from torch.utils.data import Dataset, DataLoader
from functools import partial

from exp.fastai_imports import  *

import multiprocessing
MAX_CPU = max(1, multiprocessing.cpu_count() // 2)


def getPatID(img_name):
        img_name = Path(img_name)
        eye = 'OS' if 'OS' in str(img_name) else 'OD' if 'OD' in str(img_name) else 'Unknown'
        return '_'.join(img_name.name.split('_')[:3]), eye

#export
from typing import *

def listify(o):
    if o is None: return []
    if isinstance(o, list): return o
    if isinstance(o, str): return [o]
    if isinstance(o, Iterable): return list(o)
    return [o]

def _contrast_strech(x):
    "Apply `scale` to contrast of image `x`."
    x_arr = x.data.numpy()
    plow, phigh = np.percentile(x_arr, (2, 98))

    return (x.clamp(plow,phigh)-plow)/(phigh-plow)

contrast_strech = TfmPixel(_contrast_strech)

def getLabel(fname,pathology,df):
    case_id,eye = getPatID(fname)
    return df.loc[case_id,f'{pathology}_{eye}']

def isInDf(fname,df=None):
    #default df
    df = amish_df if df is None else df

    case_id,eye = getPatID(fname)
    return case_id in df.index.to_list()

def validateNumerical(df):
    df_tmp = df.copy()
    df_num = df.select_dtypes(include=[float,int]).applymap(lambda v: v if v>=0 else np.nan)
    df_tmp[df_num.columns.to_list()] = df_num
    return df_tmp


def binarizeDataFrame(df,cat_cols,gold=True):
    df_tmp = df.copy()
    cat_cols_tmp = [c for c in cat_cols if c in df_tmp.columns]
    str2bin = {'Y':1,'N':0,'F':1,'M':0,1:1,0:0} if(gold) else {'Y':1,'N':0,'Q':0.5,'F':1,'M':0,1:1,0:0}
    df_tmp[cat_cols_tmp] = df_tmp[cat_cols_tmp].applymap(str2bin.get)
    return df_tmp


def isValidLabel(fname,pathology,df=None):
    case_id,eye = getPatID(fname)

    #default df
    df = amish_df if df is None else df

    #get label:
    label = df.loc[case_id,f'{pathology}_{eye}']

    if(isinstance(label,str)):return True
    if(np.isnan(label) | (label is None)):  return False
    return True



def getMlutiLabel(fname,pathologies,df,data_type='biomarkers'):
    case_id,eye = getPatID(fname)
    if(pathologies=='eye'): return eye

    if(data_type=='demog'):
        case_id = case_id[:9]
        return df.loc[case_id,pathologies]

    pathologies = [f'{pathology}_{eye}' for pathology in pathologies] if(type(pathologies)==list) else f'{pathologies}_{eye}'
    return df.loc[case_id,pathologies]

def areValidLabels(fname,pathologies,df=None):
    #default df
    pathologies = pathologies if(type(pathologies)==list) else [pathologies]
    df = amish_df if df is None else df
    case_id,eye = getPatID(fname)
    for p in pathologies:
        if(f'{p}_OD' in df.columns):
            if(not isValidLabel(fname,p,df=df)):
                print(fname,':',p,':',df.loc[case_id,f'{p}_{eye}'])
                return False
    return True



cat_cols = ['CO_SUBRETINAL_OD',
                 'CO_SUBRETINAL_OS',
                 'CO_SRTSRHRM_OD',
                 'CO_SRTSRHRM_OS',
                 'CO_INTRA_RCS_OD',
                 'CO_INTRA_RCS_OS',
                 'CO_OUTER_RT_OD',
                 'CO_OUTER_RT_OS',
                 'CO_SR_DRUSEN_OD',
                 'CO_SR_DRUSEN_OS',
                 'CO_HRF_IRHRFOND_OD',
                 'CO_HRF_IRHRFOND_OS',
                 'CO_HRF_HRFOD_OD',
                 'CO_HRF_HRFOD_OS',
                 'CO_PED_DPED_OD',
                 'CO_PED_DPED_OS',
                 'CO_PED_HPED_OD',
                 'CO_PED_HPED_OS',
                 'CO_PED_SEROUS_OD',
                 'CO_PED_SEROUS_OS',
                 'SO_SUBRETINAL_OD',
                 'SO_SUBRETINAL_OS',
                 'SO_SRTSRHRM_OD',
                 'SO_SRTSRHRM_OS',
                 'SO_INTRA_RCS_OD',
                 'SO_INTRA_RCS_OS',
                 'SO_OUTER_RT_OD',
                 'SO_OUTER_RT_OS',
                 'SO_SR_DRUSEN_OD',
                 'SO_SR_DRUSEN_OS',
                 'SO_HRF_IRHRFOND_OD',
                 'SO_HRF_IRHRFOND_OS',
                 'SO_HRF_HRFOD_OD',
                 'SO_HRF_HRFOD_OS',
                 'SO_PED_DPED_OD',
                 'SO_PED_DPED_OS',
                 'SO_PED_HPED_OD',
                 'SO_PED_HPED_OS',
                 'SO_PED_SEROUS_OD',
                 'SO_PED_SEROUS_OS',
            'CO_RPE_V3MM_L0.03_OD',
            'CO_RPE_V3MM_L0.03_OS',
            'CO_Drusen_Core_OD',
            'CO_Drusen_Core_OS',
            'IRP_RP_OD',
            'IRP_RP_OS'
               ]


def get_pathology_tfms(crop_size=224):

    tfms_tr = [contrast_strech(),
               pad(padding=30,mode='zeros'),
               crop(row_pct=(0.3,0.7),col_pct=0.5,size=crop_size,p=1),
               lr_flip(p=0.5),
               rotate(degrees=(-10,8),p=0.4)]

    tfms_val = [contrast_strech()]

    return [tfms_tr,tfms_val]

def get_eye_tfms(crp_h,crp_w,eps=0):

    tfms_tr = [contrast_strech(),
               crop(size=(crp_h,crp_w-eps),p=1),
               rotate(degrees=(-10,10),p=1)]

    tfms_val = [contrast_strech(),
                crop(size=(crp_h,crp_w-eps),p=1),]

    return [tfms_tr,tfms_val]

def get_tfms(img_sz,crop_size=224,eps=0,lr_flip=True,deg=10):


    row_cntr,col_cntr = get_crop_cntrs(crop_size,img_sz,eps=eps)
    img_h,img_w = img_sz if(isinstance(img_sz,tuple)) else (img_sz,img_sz)

    tfms_tr = []
    #contrast strech
    tfms_tr.append(contrast_strech())
    #random crop
    tfms_tr.append(crop(row_pct=row_cntr,col_pct=col_cntr,size=crop_size,p=1))
    #random flip
    if(lr_flip):tfms_tr.append(flip_lr(p=0.5))
    #random rotate
    tfms_tr.append(rotate(degrees=(-deg,deg),p=0.5))

    tfms_val = []
    #contrast strech
    tfms_val.append(contrast_strech())
    #remove img edges
    if(eps>0):tfms_val.append(crop(row_pct=0.5,col_pct=0.5,size=(img_h,img_w-eps),p=1))

    return [tfms_tr,tfms_val]


def get_crop_cntrs(crop_size,img_sz,eps):
    crp_h,crp_w = crop_size if(isinstance(crop_size,tuple)) else (crop_size,crop_size)
    img_h,img_w = img_sz if(isinstance(img_sz,tuple)) else (img_sz,img_sz)
#     pdb.set_trace()

    col_d = (img_w-crp_w-eps)/(2*img_w)
    row_d = (img_h-crp_w-eps)/(2*img_h)

    col_cntr = (0.5-col_d,0.5+col_d)
    row_cntr = (0.5-row_d,0.5+row_d)

    return row_cntr,col_cntr


def hooked_backward(m,xb,y):
    with hook_output(m[0]) as hook_a:
        with hook_output(m[0], grad=True) as hook_g:
            preds = m(xb)
            preds[0,int(y)].backward()
    return hook_a,hook_g,preds.cpu()

def getModelHM(data,learn,idx,normalized=False):

    #get image and label
    x,y = data.valid_ds[idx]
    m = learn.model.eval();

    #load to gpuu
    xb,_ = data.one_item(x)
    xb_im = Image(xb[0]) if not normalized else Image(data.denorm(xb)[0])
    xb = xb.cuda()

    # grab conv outputs
    hook_a,hook_g,pred_i = hooked_backward(m,xb,y)

    # load to cpuu and get avg
    acts  = hook_a.stored[0].cpu()
    avg_acts = acts.mean(0)
    return avg_acts,xb_im

def show_heatmap(hm,xb_im,h,w,ax=None):
    _,ax = plt.subplots() if ax is None else (None,ax)
    xb_im.show(ax)
    ax.imshow(hm, alpha=0.6, extent=(0,w,h,0),
              interpolation='bilinear', cmap='magma');




def plotHeatLoss(interp,k,figsize=(12,12),h=224,w=224,largest=True):
    classes = interp.data.classes


    tl_val,tl_idx = interp.top_losses(k, largest=largest)
    cols = math.ceil(math.sqrt(k))
    rows = math.ceil(k/cols)
    fig,axes = plt.subplots(rows, cols, figsize=figsize)
    fig.suptitle('prediction/actual/loss/probability', weight='bold', size=14)
    for i,idx in enumerate(tl_idx):
        im,cl = interp.data.dl(interp.ds_type).dataset[idx]
        cl = int(cl)
        avg_acts,xb_im = getModelHM(interp.data,interp.learn,idx)
        show_heatmap(avg_acts,xb_im,h,w,axes.flat[i])
        axes.flat[i].set_title(f'{classes[interp.pred_class[idx]]}/{classes[cl]} / {interp.losses[idx]:.2f} / {interp.preds[idx][cl]:.2f}')



def create_image_list(data_path, pathology, label_csv, image_type="Line", split_pct=None):
    single_task = isinstance(pathology, str)

    amish_df = pd.read_csv(label_csv, index_col='CASE_ID')
    amish_df = validateNumerical(amish_df)
    amish_df = binarizeDataFrame(amish_df, cat_cols)

    # filter functions
    areValidpathologiesLabels = partial(areValidLabels, pathologies=pathology,df=amish_df)
    isValidLabelPathology =  partial(isValidLabel, pathology=pathology, df=amish_df)
    isInAmishDf = partial(isInDf, df=amish_df)

    if isinstance(data_path, list):
        image_list = ImageList\
            .from_folder(data_path[0])
        for p in data_path[1:]:
            image_list = image_list\
                .add(ImageList.from_folder(p))
    else:
        image_list = ImageList\
            .from_folder(data_path)

    image_list = image_list\
        .filter_by_func(lambda f: image_type in f.name)\
        .filter_by_func(lambda f: 'Unknown' not in f.name)\
        .filter_by_func(lambda f: 'ERROR' not in f.name)\
        .filter_by_func(isInAmishDf)\
        .filter_by_func(areValidpathologiesLabels)

    if split_pct:
        image_list = image_list.split_by_rand_pct(split_pct)
    else:
        image_list = image_list.split_none()  # can i split none now and split by pct later?

    if single_task:
        image_list = image_list\
            .label_from_func(lambda f: getLabel(f, pathology, amish_df), label_cls=CategoryList)
            #  .label_from_func(lambda f: getMlutiLabel(f, pathology, amish_df))
            # .label_from_func(lambda f: getLabel(f, pathology, amish_df), label_cls=label_cls)
    else:
        image_list = image_list\
            .label_from_func(lambda f: getMlutiLabel(f, pathology, amish_df), label_cls=FloatList)

    return image_list

def create_amish_databunch(data_path, pathology, label_csv, batch_size=64, num_workers=MAX_CPU, val_data_path=None, split_pct=0.2, image_type="Line", CROP_SIZE=224, IMG_RSZ=224):
    """
    """
    # tfms = get_eye_tfms(CROP_SIZE)
#     tfms = get_pathology_tfms(CROP_SIZE)
    flip_flag = 'eye' not in pathology
    tfms = get_tfms(img_sz=IMG_RSZ,crop_size=CROP_SIZE,eps=16,lr_flip=flip_flag)


    if val_data_path:
        # TODO this may be a bit hacky
        image_list = create_image_list(data_path, pathology, label_csv, image_type, split_pct=None).transform(tfms, size=IMG_RSZ)
        val_image_list = create_image_list(val_data_path, pathology, label_csv, image_type, split_pct=None).transform([tfms[1], tfms[1]], size=IMG_RSZ)
        image_databunch = DataBunch.create(
            train_ds=image_list.train, valid_ds=val_image_list.train,
            bs=batch_size, num_workers=num_workers)
    else:
        # random split for now, if an explicit validation set is not provided
        image_list = create_image_list(data_path, pathology, label_csv, image_type, split_pct)
        image_list = image_list.transform(tfms, size=IMG_RSZ)
        image_databunch = image_list.databunch(bs=batch_size, num_workers=num_workers)
    return image_databunch